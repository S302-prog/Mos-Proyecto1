def analisis_de_sensibiidad(distance_matrix, time_matrices, cost_matrices, Punto3, vehicless, costosFijos, T_max):

    # Carga de matrices


    model = ConcreteModel()
    locations = list(Punto3["StandardizedID"])  
    clients = [loc for loc in locations if loc != "CD01"]
    vehicles = list(vehicless["StandardizedID"])

    # Conjuntos del modelo
    model.Locations = Set(initialize=locations)
    model.Clients = Set(initialize=clients)
    model.Vehicles = Set(initialize=vehicles)
    model.Trips = RangeSet(1, T_max)

    # Parametros de entrada 
    demand_dict = dict(zip(Punto3["StandardizedID"], Punto3["Demand"]))
    capacity_dict = dict(zip(vehicless["StandardizedID"], vehicless["Capacity"]))
    range_dict = dict(zip(vehicless["StandardizedID"], vehicless["Range"]))
    inicioTiempo = dict(zip(Punto3["StandardizedID"], Punto3["StartWindow"]))
    finTiempo = dict(zip(Punto3["StandardizedID"], Punto3["EndtWindow"]))
    # Tiempo y costo por vehiculo en diccionarios
    time_dict = time_matrices
    cost_dict = cost_matrices

    distance_dict2 = distance_matrix

    vehicle_type_dict = {}
    for _, r in vehicless.iterrows():
        vehicle_type_dict[r["StandardizedID"]] = r.get("Type", "Vehicle")

    costoFijo = dict(zip(vehicles["StandardizedID"], costosFijos))

    print(locations)

    # Parametros pyomo
    model.Demand = Param(model.Locations, initialize=demand_dict, default=0)
    model.Capacity = Param(model.Vehicles, initialize=capacity_dict)
    model.Range = Param(model.Vehicles, initialize=range_dict)
    model.Distance = Param(model.Locations, model.Locations, initialize=distance_dict2)
    model.Time = Param(model.Vehicles, model.Locations, model.Locations, initialize=time_dict)
    model.Cost = Param(model.Vehicles, model.Locations, model.Locations, initialize=cost_dict)
    model.HI_i = Param(model.Locations, initialize=inicioTiempo)
    model.HF_i = Param(model.Locations, initialize=finTiempo)

    # Variables del modelo
    model.x = Var(model.Vehicles, model.Trips, model.Locations, model.Locations, within=Binary)
    model.y = Var(model.Vehicles, within=Binary)
    model.u = Var(model.Vehicles, model.Trips, model.Clients, bounds=(0, len(clients)), within=NonNegativeIntegers)
    model.h = Var(model.Vehicles, model.Trips, model.Locations, bounds=(0, 1440))
    model.z = Var(model.Vehicles, model.Trips, within=Binary)


    def funcion_objetivo(model):
        return sum(model.Cost[v,i,j] * model.x[v,t,i,j] for v in model.Vehicles for t in model.Trips for i in model.Locations for j in model.Locations)+sum(model.y[v]*model.fijo[v] for v in model.Vehicles)
    model.obj = Objective(rule=funcion_objetivo, sense=minimize)

    # 1. Capacidad
    def capacidad_rule(model, v, t):
        return sum(model.Demand[j] * model.x[v,t,i,j]
                for i in model.Locations for j in model.Clients) <= model.Capacity[v] * model.z[v,t]
    model.capacidad = Constraint(model.Vehicles, model.Trips, rule=capacidad_rule)

    # 2. Salida del deposito 
    def start_rule(model, v, t):
        return sum(model.x[v,t,"CD01",j] for j in model.Clients) == model.z[v,t]
    model.start = Constraint(model.Vehicles, model.Trips, rule=start_rule)

    # 3. Regreso al deposito por viaje
    def end_rule(model, v, t):
        return sum(model.x[v,t,i,"CD01"] for i in model.Clients) == model.z[v,t]
    model.end = Constraint(model.Vehicles, model.Trips, rule=end_rule)

    # 4. Cada cliente visitado exactamente una vez
    def cliente_rule(model, j):
        return sum(model.x[v,t,i,j] for v in model.Vehicles for t in model.Trips for i in model.Locations if i != j) == 1
    model.cliente = Constraint(model.Clients, rule=cliente_rule)

    # 5. No subciclos
    def mtz_rule(model, v, t, i, j):
        if i != j:
            N = len(model.Clients)
            return model.u[v,t,i] - model.u[v,t,j] + N*model.x[v,t,i,j] <= N - 1
        return Constraint.Skip
    model.mtz = Constraint(model.Vehicles, model.Trips, model.Clients, model.Clients, rule=mtz_rule)

    # 6. Conservacion del flujo
    def flujo_rule(model, v, t, i):
        if i == "CD01":
            return Constraint.Skip
        return sum(model.x[v,t,i,j] for j in model.Locations if j!=i) == sum(model.x[v,t,k,i] for k in model.Locations if k!=i)
    model.flujo = Constraint(model.Vehicles, model.Trips, model.Locations, rule=flujo_rule)

    # 7. Autonomia del vehiculo 
    def autonomia_rule(model, v, t):
        return sum(model.Distance[i,j] * model.x[v,t,i,j]
                for i in model.Locations for j in model.Locations) <= model.Range[v] * model.z[v,t]
    model.autonomia = Constraint(model.Vehicles, model.Trips, rule=autonomia_rule)

    # 8. No ciclos
    def no_loop(model, v, t, i):
        return model.x[v,t,i,i] == 0
    model.no_loop = Constraint(model.Vehicles, model.Trips, model.Locations, rule=no_loop)

    # 9. Ventana de tiempo de inicio
    def ventana_inicio_rule(model, v, t, i):
        return model.h[v,t,i] >= model.HI_i[i]
    model.win_start = Constraint(model.Vehicles, model.Trips, model.Locations, rule=ventana_inicio_rule)

    # 10. Ventanas de tiempo de fin
    def ventana_fin_rule(model, v, t, i):
        return model.h[v,t,i] <= model.HF_i[i]
    model.win_end = Constraint(model.Vehicles, model.Trips, model.Locations, rule=ventana_fin_rule)

    # 11. Relación de tiempos entre nodos (propagación temporal)
    def tiempo_relacion_rule(model, v, t, i, j):

        if i == "CD01":
            return model.h[v, t, "CD01"] == model.HI_i["CD01"]
        
        if i != j and j != "CD01":
            M = 100000
            return model.h[v, t, j] >= model.h[v, t, i] + model.Time[v, i, j] - M * (1 - model.x[v, t, i, j])
        
        return Constraint.Skip

    model.tiempo_rel = Constraint(model.Vehicles, model.Trips, model.Locations, model.Locations, rule=tiempo_relacion_rule)

    # 12. Activacion del vehiculo
    def activar_vehiculo(model, v):
        return sum(model.z[v,t] for t in model.Trips) <= len(model.Trips) * model.y[v]
    model.activa = Constraint(model.Vehicles, rule=activar_vehiculo)

    # 13. Consistencia en los viajes
    def orden_viajes(model, v, t):
        if t == 1:
            return Constraint.Skip
        return model.z[v,t] <= model.z[v,t-1]
    model.order_trip = Constraint(model.Vehicles, model.Trips, rule=orden_viajes)

    solver = SolverFactory("gurobi")
    results = solver.solve(model)

    try:
        print("Objetivo:", value(model.obj))
    except:
        print("No fue posible evaluar el objetivo.")
    return model

import numpy as np
from math import radians, sin, cos, sqrt, atan2

def cargarDatos(depots, clients, vehicles, parameters):
    # Funcion para calcular distancias

    def funcion_haversine(Latitud_A, Longitud_A, Latitud_B, Longitud_B):
        Radio = 6371 
        Latitud_A, Longitud_A, Latitud_B, Longitud_B = map(radians, [Latitud_A, Longitud_A, Latitud_B, Longitud_B])
        Distancia_latitud = Latitud_A - Latitud_B
        Distancia_longitud = Longitud_A - Longitud_B
        Raiz = sqrt((sin(Distancia_latitud/2)**2) + (cos(Latitud_A)*cos(Latitud_B)*(sin(Distancia_longitud/2)**2)))
        Resultado = 2 * Radio * atan2(Raiz, 1 - Raiz)
        return Resultado

    # Creacion de la matriz distancia

    Puntos = pd.concat([depots[["StandardizedID","Latitude","Longitude"]], clients[["StandardizedID","Latitude","Longitude"]]]).reset_index(drop=True)
    n = len(Puntos)
    Matriz_distancia = np.zeros((n,n))
    Distacias = pd.DataFrame(Matriz_distancia, columns=Puntos["StandardizedID"], index=Puntos["StandardizedID"])
    distanciasP = {}
    for i in range(n):
        for j in range(n):
            Matriz_distancia[i,j] = funcion_haversine(Puntos.loc[i,"Latitude"], Puntos.loc[i,"Longitude"], Puntos.loc[j,"Latitude"], Puntos.loc[j,"Longitude"])
            distanciasP[(Puntos.loc[i, "StandardizedID"],Puntos.loc[j, "StandardizedID"])] = Matriz_distancia[i,j]
    # Creacion de la matriz de tiempos por vheiculo

    matriz_tiempo_vehiculos2 = []
    dict_tiempo_vehiculos22 = {}

    for i, vehiculo in vehicles.iterrows():
        velocidad = vehiculo["Speed"]
        tiempo_horas = Matriz_distancia / velocidad
        matriz_tiempo_vehiculos2.append(tiempo_horas)
        Tiempo = pd.DataFrame(tiempo_horas, columns=Puntos["StandardizedID"], index=Puntos["StandardizedID"])
        for i in Tiempo.index:
            for j in Tiempo.columns:
                dict_tiempo_vehiculos22[(vehiculo["StandardizedID"], i, j)] = Tiempo.loc[i, j]*60

    # Creacion de la matriz de costos por vehiculo 

    def preciocalcular(distancia, tiempo, c_dist, c_time, p_combustible, gasto_conbustible):
        costosManteniento = distancia*c_dist
        costsoTiempo = tiempo*c_time
        costsoConbustible = (distancia*p_combustible)/gasto_conbustible
        return(costosManteniento+ costsoTiempo+costsoConbustible)

    params = dict(zip(parameters["Parameter"], parameters["Value"]))
    C_dist_drone = float(params["C_dist_drone"])
    C_dist_truck = float(params["C_dist_truck"])
    C_time_drone = float(params["C_time_drone"])
    C_time_truck = float(params["C_time_truck"])
    energy_price_drone = float(params["energy_price_drone"])
    fuel_price_truck = float(params["fuel_price_truck"])
    energy_consumption_drone_min = float(params["energy_consumption_drone_min"])
    energy_consumption_drone_max = float(params["energy_consumption_drone_max"])
    energy_consumption_drone = (energy_consumption_drone_min+energy_consumption_drone_max )/2
    fuel_efficiency_truck_min = float( params["fuel_efficiency_truck_min"])
    fuel_efficiency_truck_max = float( params["fuel_efficiency_truck_max"])
    fuel_efficiency_truck = (fuel_efficiency_truck_min+fuel_efficiency_truck_max)/2
    start_time = params["start_time"]
    resupply_allowed = params["resupply_allowed"]  

    
    Matriz_costos22 = {}

    for i, vehiculo in vehicles.iterrows():
        if vehiculo["Type"] == "drone":
            costo = preciocalcular(Matriz_distancia,matriz_tiempo_vehiculos2[i],C_dist_drone,  C_time_drone,energy_price_drone,  energy_consumption_drone)
        else:
            costo = preciocalcular(Matriz_distancia,matriz_tiempo_vehiculos2[i],C_dist_truck,  C_time_truck,fuel_price_truck,  fuel_efficiency_truck)
        Costos = pd.DataFrame(costo, columns = Puntos["StandardizedID"], index = Puntos["StandardizedID"])
        for i in Costos.index:
            for j in Costos.columns:
                Matriz_costos22[(vehiculo["StandardizedID"], i, j)] = Costos.loc[i, j]

    # Cambiar el formato de las ventanas de tiempo

    clientesInicio = []
    clientesFinal = []
    for i, cliente in clients.iterrows():
        inicio = cliente["TimeWindow"].split("-")[0]
        final = cliente["TimeWindow"].split("-")[1]
        horasInicio = float(inicio.split(":")[0])
        minutosInicio = float(inicio.split(":")[1])
        horasFin = float(final.split(":")[0])
        minutosFin = float(final.split(":")[1])
        nuevaFormaInicio = horasInicio*60 + minutosInicio
        nuevaFormaFin = horasFin*60 + minutosFin
        clientesInicio.append(nuevaFormaInicio)
        clientesFinal.append(nuevaFormaFin)

    clients["StartWindow"] = clientesInicio
    clients["EndtWindow"] = clientesFinal
    clients.head()
    depots["Demand"] = 0
    inicio = start_time
    horasInicio = float(inicio.split(":")[0])
    minutosInicio = float(inicio.split(":")[1])
    nuevaFormaInicio = horasInicio*60 + minutosInicio
    depots["StartWindow"] = nuevaFormaInicio
    depots["EndtWindow"] = 1440
    Punto3 = pd.concat([depots[["StandardizedID","Latitude","Longitude","StartWindow", "EndtWindow", "Demand"]], clients[["StandardizedID","Latitude","Longitude", "StartWindow", "EndtWindow", "Demand"]]]).reset_index(drop=True)

    return Punto3,  dict_tiempo_vehiculos22, Matriz_costos22 , distanciasP, C_fixed_drone, C_fixed_truck, resupply_allowed

clients = pd.read_csv(f"Caso 3 - Avanzado Realista/clients.csv")

depots = pd.read_csv(f"Caso 3 - Avanzado Realista/depots.csv")

vehicles = pd.read_csv(f"Caso 3 - Avanzado Realista/vehicles.csv")

parameters = pd.read_csv(f"Caso 3 - Avanzado Realista/parameters_rural.csv")

[Puntos3, tiempoMT, costosMT, distanciasMT, costsoFijoDron, costoFijoTruck, resupply_allowed] = cargarDatos(depots, clients, vehicles, parameters)



modelo = analisis_de_sensibiidad(distanciasMT, tiempoMT, costosMT, Puntos3,  vehicles ,[C_fixed_drone, C_fixed_truck, C_fixed_drone],  int(2))


    